[TOC]

![image-20210728095146532](../../../Desktop/TyporaBlogMAC/图/image-20210728095146532.png)

Java对于多种不同的操作系统有不同的JVM，所以实现了真正意义上的跨平台。

并且现在能在JVM上跑的语言已经有一百多种了

jvm是虚拟出来的一台计算机，他有自己的CPU，字节码指令集（汇编语言），有自己的内存等。



# JVM结构

#### Java虚拟机栈：(线程私有)

方法内定义的所有(栈帧：

局部变量表：局部变量表就是存放方法参数和方法内部定义的局部变量的区域。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

==如果局部变量是 Java 的 8 种基本基本数据类型，则存在局部变量表中，如果是引用类型。如 new 出来的 String，局部变量表中存的是引用，而实例在堆中。==

操作数栈：比如：sum=a+b,   a压栈，b压栈，*栈顶两个元素相加，计算结果压栈*

动态链接：每个栈帧中包含一个在常量池中对当前方法的引用， 目的是支持方法调用过程的动态连接。

方法返回地址：

- 正常退出，即正常执行到任何方法的返回字节码指令，如 RETURN、IRETURN、ARETURN 等
- 异常退出

无论何种退出情况，都将返回至方法当前被调用的位置。方法退出的过程相当于弹出当前栈帧，退出可能有三种方式：

- 返回值压入上层调用栈帧
- 异常信息抛给能够处理的栈帧
- PC 计数器指向方法调用后的下一条指令

)

#### 本地方法中栈：Native方法(线程私有)，而本地方法栈则为虚拟机使用到的 Native 方法服务。

#### 堆：(线程公有)

对象分配空间(新生代[eden,from Survivor,to Survivor Edem 和俩个Survivor 区域比例是 = 8 : 1 : 1]，老年代 新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 )，所有的对象实例以及数组，字符串常量池都要在堆上分配，但是随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。

#### 方法区Perm(方法区是JVM规范的一个概念定义，并不是一个具体的实现，每一个JVM的实现都可以有各自的实现)(线程公有)

Java8版本以后，是用元空间来实现的方法区；在Java8之前的版本，则是用永久代实现的方法区。

（所以说元空间是一个具体实现，==元空间是使用本地内存（Native Memory）实现的==，也就是说它的内存是不在虚拟机内的，所以可以理论上物理机器还有多个内存就可以分配，而不用再受限于JVM本身分配的内存了。==怪不得设置虚拟机参数时可以分开设置==）

Perm 区中的==字符串常量池==被移到了堆内存中是在 Java7 之后，Java 8 时，PermGen 被元空间代替，其他内容比如类元信息、字段、静态属性、方法、常量等都移动到元空间区

==用于存放类和方法的元数据以及常量池，比如 Class 和 Method。每当一个类初次被加载的时候，它的元数据都会放到永久代中。==

#### 程序计数器：总是指向下一行要执行的命令(线程私有)

由于 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，CPU 只有把数据装载到寄存器才能够运行。寄存器存储指令相关的现场信息，由于 CPU 时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。

因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储。每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器用来存放执行指令的偏移量和行号指示器等，线程执行或恢复都要依赖程序计数器。此区域也不会发生内存溢出异常。

==cpu时间片轮转，保证线程上线文切换后，能准确的恢复回到执行的位置==

#### JIT:热点代码编译产物。

#### 堆外内存(直接内存):

# 类加载过程

#### 加载

类加载过程的一个阶段，ClassLoader通过一个类的完全限定名查找此类字节码文件，并利用字节码文件创建一个class对象。

#### 验证

目的在于确保class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身的安全，主要包括四种验证：文件格式的验证，元数据的验证，字节码验证，符号引用验证。

#### 准备

为类变量（static修饰的字段变量）分配内存并且设置该类变量的初始值，（如static int i = 5 这里只是将 i 赋值为0，在初始化的阶段再把 i 赋值为5)，这里不包含final修饰的static ，因为final在编译的时候就已经分配了。这里不会为实例变量分配初始化，类变量会分配在方法区中，实例变量会随着对象分配到Java堆中。

#### 解析

这里主要的任务是把常量池中的符号引用替换成直接引用

#### 初始化

这里是类记载的最后阶段，如果该类具有父类就进行对父类进行初始化，执行其静态初始化器（静态代码块）和静态初始化成员变量。（前面已经对static 初始化了默认值，这里我们对它进行赋值，成员变量也将被初始化）



# 类加载时机

那么什么时候加载呢？JVM中并没有规定加载的时机，它是由JVM自己把握的，**但是对于初始化确实有顺序确定的。以下五种情况进行初始化（当然也就包含了前面加载，验证，准备，解析）：**

1.遇到 **new、getstatic、putstatic、invokestatic** 这四条字节码指令时，如果类还没有进行过初始化，则需要先触发其初始化。生成这四条指令最常见的 Java 代码场景是：使用 new 关键字实例化对象时、读取或设置一个类的静态字段（static）时（被 static 修饰又被 final 修饰的，已在编译期把结果放入常量池的静态字段除外）、以及调用一个类的静态方法时。(**所以说涉及到静态的设置或者获取，都会促使类的的初始化**)

2.使用 Java.lang.refect 包的方法对类进行反射调用时，如果类还没有进行过初始化，则需要先触发其初始化。(**反射**)

3.当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。(**先父类**)

4.当虚拟机启动时，用户需要指定一个要执行的Main主类，虚拟机会先执行该主类。(**main入口类**)

5.当使用JDK1.7的动态语言时，如果一个methodHandler实例最后的解析结果的方法句柄所对应的类没有初始化则必须先出发初始化。



# 对象的内存布局

对象的内存布局一般分为三个部分：对象头，示例数据，对齐填充

对象头中存放着对象自身的运行时数据，如哈希码，GC分带年龄，锁状态标志，偏向线程ID，线程持有的锁。

对象头另外一部分还有类型指针，对象指向它类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。如果对象是一个java数组，那在对象头中还必须用一块用于记录数组长度的数据。因为虚拟机可以通过普通java对象的元数据信息确定java对象的大小。

对象的访问定位方式
句柄和直接指针
如果使用句柄的话，要在java堆中开辟一个句柄池，用来存放句柄地址，句柄地址中包含对象实例数据（堆）和类型数据（方法区）各自的地址信息。
是用句柄的好处就是引用中存储的是稳定的句柄地址，当被移动时只会修改句柄中的实例数据指针，而引用地址不会被改变。
使用直接指针访问方式的最大好处就是速度更快，它节省了一次访问指针定位的时间开销，引用直接指向存放实例数据的堆内存，在该内存中存放着指向方法区的类型数据地址。


# 对象的创建过程

当虚拟机遇到一个new的指令的时候，首先去检查这个指令是否能在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已经被加载，解析和初始化过。如果没有则执行相应初始化的过程。在类加载检查通过后，接下来虚拟机将为新生对象分配内存，对象所需要的内存的大小在类加载完成后便可以完成确定。内存分配完成以后，虚拟机需要将分配的内存空间都初始化为零值，保证了对象的实例字段在Java代码中可以不赋予初值就直接使用，程序能访问到这些字段的数据类型对应的零值。再接下来对象需要进行必要的设置，这个对象是哪个类的实例，如何才能找到这个类的元数据信息，如何找到对象的哈希码，对象的GC分带年龄。

Java堆如果是规整的采取：指针碰撞，
Java堆如果不是规整的话：空闲列表，在内存中直接分配一个足够大的内存空间划分给对象。
对象创建是非常平凡的，在多线程的程序中会产生线程安全的问题，所以解决这个问题有两种方式
使用CSA配上失败重试的方式来保证原子性
内存分配动作按照线程划分在不同的空间之中进行，即每个线程在java堆中预先分配一个小块的内存成为本地分配缓冲，TLAB,哪个线程需要分配内存就在哪个线程的TALB上分配，只有在TALB用完之后才会重新分配新的TALB的时候才会同步锁定。

# 对象的访问定位方式

句柄和直接指针
如果使用句柄的话，要在java堆中开辟一个句柄池，用来存放句柄地址，句柄地址中包含对象实例数据（堆）和类型数据（方法区）各自的地址信息。
是用句柄的好处就是引用中存储的是稳定的句柄地址，当被移动时只会修改句柄中的实例数据指针，而引用地址不会被改变。
使用直接指针访问方式的最大好处就是速度更快，它节省了一次访问指针定位的时间开销，引用直接指向存放实例数据的堆内存，在该内存中存放着指向方法区的类型数据地址。


# 一、常见的JVM实现

- `hotspot`： oracle官方，我们现在用的就是这个

  ```
  Steven@StevendeMacBook-Pro ~ % java -version 
  java version "1.8.0_92"
  Java(TM) SE Runtime Environment (build 1.8.0_92-b14)
  Java HotSpot(TM) 64-Bit Server VM (build 25.92-b14, mixed mode)
  Steven@StevendeMacBook-Pro ~ % 
  ```

- Jrockit

- J9 :IBM

- Microsoft VM

- TaobaoVM ：hotspot深度定制版

- LiquidVm：直接针对硬件

- azul zing：最新垃圾回收的业界标杆





# 二、class文件

class文件的格式是一个二进制的字节流(一般使用IDEA插件*`jclasslib`*，对class文件右键view视图可以看到类文件，然后从一个空的类，加属性，加变量，加方法，等等，分别通过插件查看生成的结构来学习。)

- Class文件是一组以8字节为基础单位的二进制流，
- 各个数据项目严格按照顺序紧凑排列在class文件中，
- 中间没有任何分隔符，这使得class文件中存储的内容几乎是全部程序运行的程序。
- Java虚拟机规范规定，Class文件格式采用类似[C语言](http://lib.csdn.net/base/c)结构体的伪结构来存储数据，这种结构只有两种数据类型：无符号数和表。

### **无符号数**

属于基本数据类型，主要可以用来描述数字、索引符号、数量值或者按照UTF-8编码构成的字符串值，大小使用u1、u2、u4、u8分别表示1字节、2字节、4字节和8字节。

### **表**

是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有的表都习惯以“_info”结尾。表主要用于描述有层次关系的复合结构的数据，比如方法、字段。需要注意的是class文件是没有分隔符的，所以每个的二进制数据类型都是严格定义的。具体的顺序定义如下：

<img src="../../../Library/Application Support/typora-user-images/image-20210810132633101.png" alt="image-20210810132633101" style="zoom:33%;" />

==在class文件中，主要分为魔数、Class文件的版本号、常量池、访问标志、类索引（还包括父类索引和接口索引集合）、字段表集合、方法表集合、属性表集合。==

## **魔数**

1. 每个Class文件的头4个字节称为魔数（Magic Number）
2. 唯一作用是用于确定这个文件是否为一个能被虚拟机接受的Class文件。
3. Class文件魔数的值为0xCAFEBABE。如果一个文件不是以0xCAFEBABE开头，那它就肯定不是[Java ](http://lib.csdn.net/base/java)class文件。

很多文件存储标准中都使用魔数来进行身份识别，使用魔术而不是使用扩展名是基于安全性考虑的——扩展名可以随意被改变!!!

## **Class文件的版本号**

紧接着魔数的4个字节是Class文件版本号，版本号又分为：

1. 次版本号(minor_version): 前2字节用于表示次版本号
2. 主版本号(major_version): 后2字节用于表示主版本号。

Java的版本号是从45开始的。如果Class文件的版本号超过虚拟机版本，将被拒绝执行。

 0X0034（对应十进制的50）：JDK1.8    
 0X0033（对应十进制的50）：JDK1.7    
 0X0032（对应十进制的50）：JDK1.6    
 0X0031（对应十进制的49）：JDK1.5　　
 0X0030（对应十进制的48）：JDK1.4　　
 0X002F（对应十进制的47）：JDK1.3　　
 0X002E（对应十进制的46）：JDK1.2 

ps：0X表示16进制

## **常量池**

 紧接着魔数与版本号之后的是常量池入口.常量池简单理解为class文件的资源从库。

由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值(constant_pool_count)。

常量池之中主要存放两大类常量：

1. 字面量: 比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等
2. 符号引用: 属于编译原理方面的概念，包括了下面三类常量:

- 　　类和接口的全限定名
- 　　字段的名称和描述符
- 　　方法的名称和描述符



## **访问标志（2字节）**

常量池之后的数据结构是访问标志(access_flags),这个标志主要用于识别一些类或接口层次的访问信息，主要包括：

- 是否final
- 是否public，否则是private
- 是否是接口
- 是否可用invokespecial字节码指令
- 是否是abstact
- 是否是注解
- 是否是枚举



## **类索引、父类索引和接口索引集合**

这三项数据主要用于确定这个类的继承关系。
其中类索引(this_class)和父类索引(super_class)都是一个u2类型的数据，而接口索引(interface)集合是一组u2类型的数据。(多实现单继承)
类索引(this_class)，用于确定这个类的全限定名，占2字节
父类索引(super_class)，用于确定这个类父类的全限定名（Java语言不允许多重继承，故父类索引只有一个。除了java.lang.Object类之外所有类都有父类，故除了java.lang.Object类之外，所有类该字段值都不为0），占2字节
接口索引计数器(interfaces_count)，占2字节。如果该类没有实现任何接口，则该计数器值为0，并且后面的接口的索引集合将不占用任何字节，
接口索引集合(interfaces)，一组u2类型数据的集合。用来描述这个类实现了哪些接口，这些被实现的接口将按implements语句（如果该类本身为接口，则为extends语句）后的接口顺序从左至右排列在接口的索引集合中



## **字段表集合**

fields_count：字段表计数器，即字段表集合中的字段表数据个数，占2字节。本测试类其值为0x0001，即只有一个字段表数据，也就是测试类中只包含一个变量（不算方法内部变量）
fields：字段表集合，一组字段表类型数据的集合。字段表用于描述接口或类中声明的变量，包括类级别（static）和实例级别变量，不包括在方法内部声明的变量

| 类型           | 名称             | 数量             | 说明                                              |
| -------------- | ---------------- | ---------------- | ------------------------------------------------- |
| u2             | access_flags     | 1                | 修饰符标记位                                      |
| u2             | name_index       | 1                | 代表字段的简单名称，占2字节，是一个对常量池的引用 |
| u2             | descriptor_index | 1                | 代表字段的类型，占2个字节，是一个对常量池的引用   |
| u2             | attributes_count | 1                | 属性计数器                                        |
| attribute_info | attributes       | attributes_count | 属性表集合                                        |

## **方法表集合**

methods_count：方法表计数器，即方法表集合中的方法表数据个数。占2字节，其值为0x0002，即测试类中有2个方法
methods：方法表集合，一组方法表类型数据的集合。方法表结构和字段表结构一样。

2个字节为属性计数器，其值为0x0001，说明这个方法的属性表集合中有一个属性（详细说明见后面“属性表集合”）
属性名称为接下来2个字节0x0009，指向常量池中第9个常量，Code。

==方法表结构和字段表结构一样==

## 属性表集合

起始2个字节为0x0001，说明有一个类属性。
接下来2个字节为属性的名称，0x0010，指向常量池中第16个常量：SourceFile。
接下来4个字节为0x00000002，说明属性体长度为2字节。
最后2个字节为0x0011，指向常量池中第27个常量：TestClass.java，即这个Class文件的源码文件名为TestClass.java



### JIT (即时编译)技术[直接将热点代码缓存成机器码，减少解释过程]

我们大家都知道，通过 javac 将可以将Java程序源代码编译，转换成 java 字节码，JVM 通过解释字节码将其翻译成对应的机器指令，逐条读入，逐条解释翻译。这就是传统的JVM的解释器（Interpreter）的功能。很显然，Java编译器经过解释执行，其执行速度必然会比直接执行可执行的二进制字节码慢很多。为了解决这种效率问题，引入了 JIT（Just In Time ，即时编译） 技术。

有了JIT技术之后，Java程序还是通过解释器进行解释执行，当JVM发现某个方法或代码块运行特别频繁的时候，就会认为这是“热点代码”（Hot Spot Code)。然后JIT会把部分“热点代码”翻译成本地机器相关的机器码，并进行优化，然后再把翻译后的机器码缓存起来，以备下次使用。

### 什么是热点代码？

基于计数器的热点探测（Counter Based Hot Spot Detection)。采用这种方法的虚拟机会为每个方法，甚至是代码块建立计数器，统计方法的执行次数，某个方法超过阀值就认为是热点方法，触发JIT编译。

#### 编译优化

JIT在做了热点检测识别出热点代码后，除了会对其字节码进行缓存，还会对代码做各种优化。这些优化中，比较重要的几个有：==逃逸分析、 锁消除、 锁膨胀(原来锁优化在这里)、 方法内联、 空值检查消除、 类型检测消除、 公共子表达式消除==等。

### 逃逸分析(逃逸分析的基本行为就是分析对象动态作用域:决定分配堆还是栈)

逃逸分析(Escape Analysis)是目前Java虚拟机中比较前沿的优化技术。这是一种可以有效减少Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。

逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为==方法逃逸==。

例如：

```
public static String craeteStringBuffer(String s1, String s2) {
 
    StringBuffer sb = new StringBuffer();
 
    sb.append(s1);
 
    sb.append(s2);
 
    return sb.toString();
 

sb是一个方法内部变量，上述代码中并没有将他直接返回，这样这个StringBuffer又不会被其他方法所改变，这样它的作用域就只是在方法内部。我们就可以说这个变量并没有逃逸到方法外部。

```

有了逃逸分析，我们可以判断出一个方法中的变量是否有可能被其他线程所访问或者改变，那么基于这个特性，JIT就可以做一些优化：

- 同步省略
- 标量替换
- 栈上分配

本文主要来分析下标量替换和栈上分配。

#### 同步消除(Synchronization Elimination)

对于多线程的应用而言，我们通过同步代码块实现线程的安全。然而线程同步代码块也是一个相当耗费性能的过程。如果通过逃逸分析确定这个对象不会逃逸出线程，即无法被其他线程访问，那么这个变量的读写肯定就不会有竞争，这样,我们就可以大胆的把同步线程代码块消除。

#### 栈上分配(在栈上分配内存，目前没有实施)

我们说，JIT经过逃逸分析之后，如果发现某个对象并没有逃逸到方法体之外的话，就可能对其进行优化，而这一优化最大的结果就是可能改变Java对象都是在堆上分配内存的这一原则。

对象要分配在堆上其实有很多原因，但是有一点比较关键的和本文有关的，那就是因为堆内存在访问上是线程共享的，这样一个线程创建出来的对象，其他线程也能访问到。

==**那么，试想下，如果我们在某一个方法体内部创建了一个对象，并且对象并没有逃逸到方法外的话，那还有必要一定要把对象分配到堆上吗？**==

其实就没有必要了，因为这个对象并不会被其他线程所访问到，生命周期也只是在一个方法内部，也就不用大费周折的在堆上分配内存，也减少了内存回收的必要。(靠，牛逼直接解决了我的困惑)

那么，有了逃逸分析之后，发现一个对象并没有逃逸到放法外的话，通过什么办法可以进行优化，减少对象在堆上分配可能呢？

这就是栈上分配。在HotSopt中，栈上分配并没有正在的进行实现，而是通过标量替换来实现的。

所以我们重点介绍下，什么是标量替换，如何通过标量替换实现栈上分配。

#### 标量替换(将对象分解成成员变量分配在栈上)

标量（Scalar）是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。相对的，那些还可以分解的数据叫做聚合量（Aggregate），Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。

在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。

```php
public static void main(String[] args) {
 
   alloc();
 
}
 
private static void alloc() {
 
   Point point = new Point（1,2）;
 
   System.out.println("point.x="+point.x+"; point.y="+point.y);
 
}
 
class Point{
 
    private int x;
 
    private int y;
 
}
 
```

以上代码中，point对象并没有逃逸出alloc方法，并且point对象是可以拆解成标量的。那么，JIT就会不会直接创建Point对象，而是直接使用两个标量int x ，int y来替代Point对象。

```php
private static void alloc() {
 
   int x = 1;
 
   int y = 2;
 
   System.out.println("point.x="+x+"; point.y="+y);
 
}
```

可以看到，Point这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个聚合量了。

==通过标量替换，原本的一个对象，被替换成了多个成员变量。而原本需要在堆上分配的内存，也就不再需要了，完全可以在本地方法栈中完成对成员变量的内存分配。==

### 实验证明

Talk Is Cheap, Show Me The Code

No Data, No BB；

接下来我们就来通过一个实验，来看一下逃逸分析是否可以生效，生效后是否真的会发生栈上分配，而栈上分配又有什么好处呢？

我们来看以下代码：

```php
public static void main(String[] args) {
 
    long a1 = System.currentTimeMillis();
 
    for (int i = 0; i < 1000000; i++) {
 
        alloc();
 
    }
 
    // 查看执行时间
 
    long a2 = System.currentTimeMillis();
 
    System.out.println("cost " + (a2 - a1) + " ms");
 
    // 为了方便查看堆内存中对象个数，线程sleep
 
    try {
 
        Thread.sleep(100000);
 
    } catch (InterruptedException e1) {
 
        e1.printStackTrace();
 
    }
 
}
 
private static void alloc() {
 
    User user = new User();
 
}
 
static class User {
 
}
```

其实代码内容很简单，就是使用for循环，在代码中创建100万个User对象。

我们在alloc方法中定义了User对象，但是并没有在方法外部引用他。也就是说，这个对象并不会逃逸到alloc外部。经过JIT的逃逸分析之后，就可以对其内存分配进行优化。

我们指定以下JVM参数并运行：

```php
-Xmx4G -Xms4G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError 
```

其中-XX:-DoEscapeAnalysis表示关闭逃逸分析。

在程序打印出 cost XX ms 后，代码运行结束之前，我们使用jmap命令，来查看下当前堆内存中有多少个User对象：

```php
➜  ~ jmap -histo 2809
 
 num     #instances         #bytes  class name
----------------------------------------------
 
   1:           524       87282184  [I
 
   2:       1000000       16000000  StackAllocTest$User
 
   3:          6806        2093136  [B
 
   4:          8006        1320872  [C
 
   5:          4188         100512  java.lang.String
 
   6:           581          66304  java.lang.Class
```

从上面的jmap执行结果中我们可以看到，堆中共创建了100万个StackAllocTest

在关闭逃逸分析的情况下（-XX:-DoEscapeAnalysis），虽然在alloc方法中创建的User对象并没有逃逸到方法外部，但是还是被分配在堆内存中。也就说，如果没有JIT编译器优化，没有逃逸分析技术，正常情况下就应该是这样的。即所有对象都分配到堆内存中。

接下来，我们开启逃逸分析，再来执行下以上代码。

```php
-Xmx4G -Xms4G -XX:+DoEscapeAnalysis -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError 
 
```

在程序打印出 cost XX ms 后，代码运行结束之前，我们使用jmap命令，来查看下当前堆内存中有多少个User对象：

```php
➜  ~ jmap -histo 2859 num     #instances         #bytes  class name----------------------------------------------    1:           524      101944280  [I    2:          6806        2093136  [B    3:         83619        1337904  StackAllocTest$User    4:          8006        1320872  [C    5:          4188         100512  java.lang.String    6:           581          66304  java.lang.Class 
```

从以上打印结果中可以发现，开启了逃逸分析之后（−XX:+DoEscapeAnalysis），在堆内存中只有8万多个StackAllocTestUser对象。也就是说在经过JIT优化之后，堆内存中分配的对象数量，从100万降到了8万。

除了以上通过jmap验证对象个数的方法以外，读者还可以尝试将堆内存调小，然后执行以上代码，根据GC的次数来分析，也能发现，开启了逃逸分析之后，在运行期间，GC次数会明显减少。正是因为很多堆上分配被优化成了栈上分配，所以GC次数有了明显的减少。

### 逃逸分析并不成熟

前面的例子中，开启逃逸分析之后，对象数目从100万变成了8万，但是并不是0，说明JIT优化并不会完完全全的所有情况都进行优化。

关于逃逸分析的论文在1999年就已经发表了，但直到JDK 1.6才有实现，而且这项技术到如今也并不是十分成熟的。

其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。

一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。

虽然这项技术并不十分成熟，但是他也是即时编译器优化技术中一个十分重要的手段。

### 总结

JIT->进行热点代码持久化，优化逃逸分析和锁消除

逃逸分析->同步消除，标量替换，栈上分配

正常情况下，对象是要在堆上进行内存分配的，但是随着编译器优化技术的成熟，虽然虚拟机规范是这样要求的，但是具体实现上还是有些差别的。

如HotSpot虚拟机引入了JIT优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存。

==所以，对象一定在堆上分配内存，这是不对的。==



#### 为什么对象要分配到堆上？

因为堆是所有线程共享的。Java堆中的对象是对于各个线程都是共享和可见的，主要持有这个对象的引用，就可以轻松访问存储在对象的数据

# 三、GC



**Minor GC：**发生在Young space中的gc

**Major GC：**发生在老年代Tenured space中的gc

**STW(stop the world)：**指的是用户线程在运行至安全点（safe point）或安全区域（safe region）之后，就自行挂起，进入暂停状态，对外的表现就是卡顿，而不论何种gc算法，不论是minor gc还是major gc都会STW，区别只在于STW的时间长短。

**Full GC：**无官方定义，通常意义上而言指的是一次特殊GC的行为描述，这次GC会回收整个堆的内存，包含老年代，新生代，metaspace等。Full GC定义是相对明确的，就是针对整个新生代、老生代、元空间（metaspace，java8以上版本取代perm gen）的全局范围的GC；
但是实际情况中，我们主要看的是gc.log日志，其中也会发现在部分gc日志头中也有Full GC字眼，此处表示含义是在这次GC的全过程中，都是STW的状态，也就是说在这次GC的全过程中所有用户线程都是处于暂停的状态。



一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理),这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度(默认15岁)时，就会被移动到年老代中。

因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以年轻代的垃圾回收算法采用复制算法(内存分为两块，每次只用其中一块，当一块内存用完，就将还活着的对象复制到另外一块内存上，复制算法不产生内存碎片)。在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。

### 总结下来，JVM的堆区对象分配的规则一般如下：

1)对象优先在Eden区分配

2)大对象直接进入老年代（-XX:PretenureSizeThreshold=3145728 该参数来定义进入老年代对象大小）

3)长期存活的对象将进入老年代(在JDK8中-XX:MaxTenuringThreshold=1的阀值设定根本没用)

4)动态对象年龄判定（虚拟机并不会永远地要求对象的年龄都必须达到MaxTenuringThreshold才能晋升老年代，如果Survivor空间中相同年龄的所有对象的大小总和大于Survivor的一半，年龄大于或等于该年龄的对象就可以直接进入老年代）

5)空间分配担保

6)只要老年代的连续空间大于（新生代所有对象的总大小或者历次晋升的平均大小）就会进行minor GC，否则会进行full GC



## 垃圾收集算法：



1.标记-清除算法（Mark-Sweep）（老年代使用）：分为标记和清楚两个阶段。缺点：1.标记清除效率低2.内存碎片化

2.复制算法（copying） （年轻代使用）：分为两块内存，每次使用一块内存，将存活对象复制另一块内存。缺点：耗内存

3.标记整理算法(Mark-Compact) （老年代使用）：结合上面两种方法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后**直接清理掉端边界以外的内存)**

##### 4.分代收集算法（相当于是把上面的回收算法，搭配使用，正在使用）

当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，根据对象存活周期的不同将内存划分为几块并采用不用的垃圾收集算法。

一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。



#### 垃圾收集器：如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。

##### Serial收集器（串行收集器）：

这是一个单线程的收集器

##### ParNew收集器：

ParNew收集器ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括 Serial 收集器可用的所有控制参数（例如：-XX:SurvivorRatio、-XX:PretenureSizeThreshold、-XX:HandlePromotionFailure等）

##### Parallel Scavenge收集器：

Parallel Scavenge 收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器……看上去和 ParNew 都一样。目标则是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值。

##### Serial Old 收集器：

Serial Old 是 Serial 收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”算法。

##### Parallel Old收集器：

Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和“标记-整理”算法。

##### CMS收集器：(并发收集、低停顿)

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。

目前很大一部分的 Java 应用集中在互联网站或者 B/S 系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS 收集器就非常符合这类应用的需求。

从名字（包含"Mark Sweep"）上就可以看出，CMS 收集器是基于“标记—清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为4个步骤，包括：

1. 初始标记（CMS initial mark）
2. 并发标记（CMS concurrent mark）
3. 重新标记（CMS remark）
4. 并发清除（CMS concurrent sweep）

##### G1收集器:

在 G1 之前的其他收集器进行收集的范围都是整个新生代或者老年代（==之前都是分代垃圾回收==），而 G1 不再是这样。使用 G1 收集器时，Java 堆的内存布局就与其他收集器有很大差别，它将整个 Java 堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分 Region （不需要连续）的集合。

**并行与并发：** G1 能充分利用多 CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短 Stop-The-World 停顿的时间，部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 Java 程序继续执行。

**分代收集：** 与其他收集器一样，分代概念在 G1 中依然得以保留。虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次 GC 的旧对象以获取更好的收集效果。

**空间整合：** 与 CMS 的“标记—清理”算法不同，G1 从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着 G1 运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC 。

**可预测的停顿：** 这是 G1 相对于 CMS 的另一大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时 Java（RTSJ）的垃圾收集器的特征了。



如果不计算维护 Remembered Set 的操作，G1 收集器的运作大致可划分为以下几个步骤：

1. 初始标记（Initial Marking）
2. 并发标记（Concurrent Marking）
3. 最终标记（Final Marking）
4. 筛选回收（Live Data Counting and Evacuation）

### **GC的触发条件**

PS:JVM优化的目的就是减少SWT执行的时间（避免卡顿），避免频繁full gc
1)System.gc()方法的调用。
此方法的调用是建议JVM进行Full GC,虽然只是建议而非一定，但很多情况下它会触发 Full GC,从而增加Full GC的频率，也即增加了间歇性停顿的次数。强烈影响系建议能不使用此方法就别使用，让虚拟机自己去管理它的内存，可通过通过-XX:+ DisableExplicitGC来禁止RMI（Java远程方法调用）调用System.gc。

2)旧生代空间不足。旧生代空间只有在新生代对象转入及创建为大对象、大数组时才会出现不足的现象，当执行Full GC后空间仍然不足，则抛出错误：java.lang.OutOfMemoryError: Java heap space 。为避免以上两种状况引起的FullGC，调优时应尽量做到让对象在Minor GC阶段被回收、让对象在新生代多存活一段时间及不要创建过大的对象及数组。

3)Permanet Generation空间满了。Permanet Generation中存放的为一些class的信息等，当系统中要加载的类、反射的类和调用的方法较多时，Permanet Generation可能会被占满，在未配置为采用CMS GC的情况下会执行Full GC。如果经过Full GC仍然回收不了，那么JVM会抛出错误信息：java.lang.OutOfMemoryError: PermGen space 。为避免Perm Gen占满造成Full GC现象，可采用的方法为增大Perm Gen空间或转为使用CMS GC。

4)通过Minor GC后进入老年代的平均大小大于老年代的可用内存

5)由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代可用内存不足(老年代可用内存小于该对象)



# 判断一个对象是否可以被回收

1.引用计数法：有循环引用的问题。

2.可达性分析法：

不可达的对象将暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：

1. 如果对象在进行可达性分析后发现**没有与 GC Roots 相连接的引用链**，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 `finalize()` 方法。
2. 当对象没有覆盖 `finalize()` 方法，或者 `finalize()` 方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”，直接进行第二次标记。
3. 如果这个对象被判定为有必要执行 `finalize()` 方法，那么这个对象将会放置在一个叫做 F-Queue 的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的 Finalizer 线程去执行它。

注：

说明：finalize()函数是在JVM回收内存时执行的，但JVM并不保证在回收内存时一定会调用finalize()。

```
// 覆盖finalize()方法    protected void finalize() throws Throwable {        super.finalize();        System.out.println("obj [Date: " + this.getTime() + "] is gc");    }   
```

### GCRoots对象有哪些？

这种算法目前定义了几个root，也就是这几个对象是jvm虚拟机不会被回收的对象，所以这些对象引用的对象都是在使用中的对象，这些对象未使用的对象就是即将要被回收的对象。简单就是说：如果对象能够达到root，就不会被回收，如果对象不能够达到root，就会被回收。(GCroot对象就是一些固定不会被回收的对象)

一个对象可以属于多个root，GC root有几下种

- 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 本地方法栈中 JNI（即一般说的 Native 方法）引用的对象
- 方法区中的类静态属性引用的对象
- 方法区常量引用的对象

(总结下来：java虚拟机栈活跃线程对象，本地方法栈引用对象，方法区静态，常量引用对象，启动类加载的对象，)



## 对象强弱：

Strong Reference ：强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题.

```
Object obj = new Object();//由于是强引用，不会被回收
```

Soft Reference ：软引用是用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。==软引用可用来实现内存敏感的高速缓存==。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。

```
SoftReference ref = new SoftReference(new MyDate());
```

Weak Reference ： 弱引用也是用来描述非必须对象的，他的强度比软引用更弱一些，被弱引用关联的对象，在垃圾回收时，如果这个对象只被弱引用关联（没有任何强引用关联他），那么这个对象就会被回收。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。

无论其引用的对象是否root可达，在响应内存需要时，由垃圾回收判断是否需要回收。

```
WeakReference ref = new WeakReference(new MyDate());
```

Phantom Reference ：“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获取一个对象的实例。在任何时候都可能被垃圾回收器回收。==虚引用主要用来跟踪对象被垃圾回收器回收的活动==。虚引用与软引用和弱引用的一个区别在于：==虚引用必须和引用队列 （ReferenceQueue）联合使用。==当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之 关联的引用队列中。

```
				ReferenceQueue queue = new ReferenceQueue();        PhantomReference ref = new PhantomReference(new MyDate(), queue);        System.gc();
```

| 强引用(StrongReference) | 永远不会回收(GC ROOT可引用到的前提下) | 最基本的引用Object obj=new Object() |
| ----------------------- | ------------------------------------- | ----------------------------------- |
| 软引用(SoftReference)   | OOM之前回收                           | SoftReference                       |

| 弱引用(WeakReference)    | 下一次GC前                 | WeakReference    |
| ------------------------ | -------------------------- | ---------------- |
| 虚引用(PhantomReference) | 未知，也就是随时可能被回收 | PhantomReference |



# 双亲委派

#### 内置的类加载器

##### Bootstrap Class Loader

bootstrap class loader 是 JVM 核心的一部分，是使用 native 代码编写的，所以在不同的平台上（如windows,linus,macos）,有不同的实现；

Bootstrap Class Loader 负载加载 JDK 内部类，这些内部类在目录 $JAVA_HOME/jre/lib 下，比如 rt.jar；

#####  Extension Class Loader

extension class loader 负责加载JDK的扩展类，这些扩展类一般在目录 $JAVA_HOME/lib/ext 下，或系统变量 java.ext.dirs 指定的其它目录;

##### System/application Class Loader

system class loader 负责加载 JAVA 应用级别的类， 这些类都在环境变量 classpath 指定的目录下，用户在提交 JAVA 程序时，可以通过命令行参数 -classpath 或 -cp 指定环境变量 classpath。



#### 双亲委派流程

1.当类加载器收到一个类或资源的加载请求后，会首先搜索该类或资源是否已经被加载到内存中了，如果已经被加载了的话，不会重复加载该类或资源；如果没有被加载，则会将加载请求委派给父级加载器去加载；(在内存中搜索时，一样会遵循类的可见性，类的可见性的具体含义见下文)

2.父级加载器一样遵循向上委派机制，将加载请求委派给其父级加载器去加载，通过这种向上传导关系，所有的类加载请求，最终都会被传入到启动类加载器(Bootstrap ClassLoader)中；

3.只有当父级加载器反馈无法完成特定类或资源的加载请求时，即父级加载器在它的搜索范围内找不到该类或资源时，子级加载器才尝试在自己的搜索范围内加载类或资源；

4.如果所有的父级加载器在其搜索范围内都找不到该类或资源，且子级加载器在自己的搜索范围内也找不到该类或资源，JVM 就会报 java.lang.ClassNotFoundException；

(==即类加载器找不到该类就会classNotFoundException==)

遵循以上双亲委派模型，当我们需要加载一个应用类到 JVM 中时：

system class loader 首先搜索 jvm 内存，发现该类没有被加载过，然后会委派该加载请求给其父类加载器 extension class loader；

extension class loader 又会将该加载请求委派给其父类 bootstrap class loader；

bootstrap class loader 尝试加载该类，会在其搜索范围内（即目录 $JAVA_HOME/jre/lib）尝试查找该类，找不到;

然后 extension class loader 才会尝试加载该类，在其搜索范围内（即目录 $JAVA_HOME/lib/ext 下，或系统变量 java.ext.dirs 指定的其它目录下）尝试查找该类，找不到；

然后 system class loader 才会尝试自己加载该类，会在其搜索范围内（环境变量 classpath 指定的目录下）尝试查找该类，查找成功，加载成功。

### 作用：

类的唯一性 uniqueness：只有在父类加载器在其搜索范围内找不到类，无法加载类时，子类加载器才会尝试自己加载，这样就避免了重复加载，确保了类的唯一性

2.类的可见性 Visibility：父类加载器加载的类对子类加载器（加载的类）可见，而子类加载器加载的类对父类加载器（加载的类）不可见：（所谓的可见，即能访问）：即 system class loader 加载的类，可见 extension 和 Bootstrap class loaders 加载的类，反过来则不可见；比如，Class A 是 application class loader 加载的，而 class B 是 extensions class loader 加载的, 则此时 Application class loader 加载的其它类，可以访问 A 和 B; 而 extenson class loader 加载的其它：类， 则只可以访问 B 而不能访问A;
3.类的安全性 Security：双亲委派模型实现了类的唯一性和可见性，避免了用户随意定义类加载器加载核心 API 带来的安全隐患，从而进一步确保了类的安全性；

（唯一性：确保只有一个类加载器能加载，可见性：父类加载器加载的类不可访问子类加载的类，安全性：避免随意定义类）

### 钻石依赖

项目管理上有一个著名的概念叫着「钻石依赖」，是指软件依赖导致同一个软件包的两个版本需要共存而不能冲突。

==在JVM方法区中，是以：classLoader实例对象+类全限定名确定唯一的==，也就是说只要保证类加载器实例对象不一样，就能保证同一个软件包的两个版本共存。

具体方法参考：https://www.cnblogs.com/changxy-codest/p/15846157.html

==大致流程：1.将不同版本类打包成maven插件，解决依赖冲突2.使用自定义类加载器进行加载。==
