# CAP

- Consistency 一致性
- Availability 可用性
- Partition tolerance 分区容错性

CAP其实是一种权衡平衡的思想，用于指导在系统可用性设计、数据一致性设计时做权衡取舍。

分布式系统的最大难点，就是各个节点的状态如何同步。CAP 定理是这方面的基本定理，也是理解分布式系统的起点。

(分布式系统一定会满足其中两个特征)



### P 分区容错性

每个网络区域，可以认为是一个区，而每个区进行通信，我们需要保证他们能够正常进行通信，这是基础。所以这个特性必有

分布式系统在遇到网络故障的时候，仍然能够对外提供满足一致性和可用性的服务，除非整个网络环境都发生了故障。

(网络问题必定存在，所以P必定需要，除非单台服务器，但是那就不是分布式了)



### C一致性

数据可能存在于不同的物理节点上,节点之间只能通过网络进行通信来协调彼此之间的状态,而网络通信需要时间并且其本身并不十分可靠,因而如何保持数据一致性成为了分布式系统的难题。

分布式系统有多台机器，每一次的更新，插入操作，后面对应的必定是有多台机器，插入到A中，确保B也会插入。

因为访问数据时，请求可能访问A，也可能是B，为了保证结果一致，所以在更新A时，B也必须更新。



#### A可用性

很简单，发起一次操作后，不管是A也好，B也好，总是你必须及时回应请求。



因为P是必定有的，那为什么C和A是排斥的呢，如果想要保持C，那么两台机器之间进行数据同步，可能出现延时或同步失败的情况，这段时间，机器就是不可用的，那么就不满足可用性了。



（是不是觉得P和A很像，其实两者服务对象不一样，P指的是内部系统之间调用出现故障，也能保持内部各服务之间稳定调用。 A指的是系统挂了，其他的系统能继续为用户提供服务）



# BASE 理论

BASE 理论， 是对CAP中AP的一个扩展，对于我们的业务系统，我们考虑牺牲一致性来换取系统的可用性和分区容错性。BASE是Basically Available(基本可用)，Soft state（软状态）,和 Eventually consistent（最终一致性）三个短语的缩写。

通过牺牲强一致性来获得可用性，当出现故障允许部分不可用但要保证核心功能可用，允许数据在一段时间内是不一致的，但最终达到一致状态。满足BASE理论的事务，我们称之为“**柔性事务**”。

- **基本可用**：分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。如电商网站交易付款出现问题了，商品依然可以正常浏览。
- **软状态**：由于不要求强一致性，所以BASE允许系统中存在中间状态（也叫**软状态**），这个状态不影响系统可用性，如订单的"支付中"、“数据同步中”等状态，待数据最终一致后状态改为“成功”状态。
- **最终一致**：最终一致是指经过一段时间后，所有节点数据都将会达到一致。如订单的"支付中"状态，最终会变 为“支付成功”或者"支付失败"，使订单状态与实际交易结果达成一致，但需要一定时间的延迟、等待。
- 基本可用是指，通过支持局部故障而不是系统全局故障来实现的；
- Soft State表示状态可以有一段时间不同步；
- 最终一致，最终数据是一致的就可以了，而不是实时保持强一致。



# 幂等性

**所谓幂等，就是任意多次执行所产生的影响均与一次执行的影响相同**

(多次操作和一次操作产生的影响相同，如查询接口，天然的幂等性，只是查询没有其他影响)



# 分布式事务

分布式事务指事务的操作位于不同的节点上，需要保证事务的 AICD 特性。

例如在下单场景下，库存和订单如果不在同一个节点上，就涉及分布式事务。

(保证多个不同服务器事务，在同一个事务里)

### 两阶段提交（Two-phase Commit，2PC）

通过引入协调者（Coordinator）来协调参与者的行为，并最终决定这些参与者是否要真正执行事务。

![image-20210927144917049](file:///Users/ganxinming/Library/Application%20Support/typora-user-images/image-20210927144917049.png?lastModify=1646877344)

它将整个事务流程分为两个阶段，准备阶段（Prepare phase）、提交阶段（commit phase）。

1.准备阶段：协调者询问参与者事务是否执行成功，参与者发回事务执行结果。

2.提交阶段：如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务。

需要注意的是，在准备阶段，参与者执行了事务，但是还未提交。只有在提交阶段接收到协调者发来的通知后，才进行提交或者回滚。

(通过一个协调者，询问是否全部执行完成，如果完成，发送消息允许提交事务，如果失败，发送消息提示回滚事务)

#### 存在问题

- 同步阻塞，2PC的两个阶段中，协调者和参与者的通信都是同步的，这会导致整个事务的长时间阻塞
- Coordinator协调者的单点故障问题。
- 数据不一致，在Commit阶段，可能存在只有部分参与者收到Commit消息（或处理成功）的情况

**当然这只是协议，具体的落地还是可以变通了**，比如协调者单点问题，我就搞个主从来实现协调者，对吧。

### 三阶段提交3PC

3PC 的引入是为了解决 2PC 同步阻塞和减少数据不一致的情况。

跟2PC类似，只不过将准备阶段，拆分成了CanCommit和PreCommit两个阶段，3PC 也就是多了一个阶段，一个询问的阶段，分别是==准备、预提交和提交==这三个阶段。同时引入超时机制来解决2PC的同步阻塞问题。

**看起来是把 2PC 的提交阶段变成了预提交阶段和提交阶段，但是 3PC 的准备阶段协调者只是询问参与者的自身状况，比如你现在还好吗？负载重不重？这类的。**

**而预提交阶段就是和 2PC 的准备阶段一样，除了事务的提交该做的都做了。**

3PC 多了一个阶段其实就是在执行事务之前来确认参与者是否正常，防止个别参与者不正常的情况下，其他参与者都执行了事务，锁定资源。

(1.多了个检查参与是否正常2.引入超时机制，如果超时直接取消，而不会继续同步阻塞)

再提一下，2PC 还是 3PC 都是协议，可以认为是一种指导思想，和真正的落地还是有差别的。

### XA(是2PC协议的具体实现)

XA是一种基于2PC协议实现的规范。在2PC中没有明确资源是什么，以及资源是怎么提交的等等，而XA就是数据库实现2PC的规范，已知常用的支持XA的关系型数据库有Mysql、Oracle等。

### TCC

**不管是 2PC 还是 3PC 都是依赖于数据库的事务提交和回滚。**

而有时候一些业务它不仅仅涉及到数据库，可能是发送一条短信，也可能是上传一张图片。

所以说事务的提交和回滚就得提升到业务层面而不是数据库层面了，而 **TCC 就是一种业务层面或者是应用层的两阶段提交。**

- Try阶段，对业务资源进行检测和预留
- Confirm阶段，对Try阶段预留的资源进行确认提交，Try阶段执行成功是Confirm阶段执行成功的前提
- Cancel阶段，对Try阶段预留的资源进行撤销或释放

TCC 分为两个阶段，第一阶段是资源检查预留阶段即 Try，第二阶段是提交或回滚，如果是提交的话就是执行真正的业务操作，如果是回滚则是执行预留资源的取消，恢复初始状态。

比如有一个扣款服务，我需要写 Try 方法，用来冻结扣款资金，还需要一个 Confirm 方法来执行真正的扣款，最后还需要提供 Cancel 来进行冻结操作的回滚，对应的一个事务的所有服务都需要提供这三个方法。

可以看到本来就一个方法，现在需要膨胀成三个方法，所以说 TCC 对业务有很大的侵入，像如果没有冻结的那个字段，还需要改表结构。

![image-20210927155734338](file:///Users/ganxinming/Library/Application%20Support/typora-user-images/image-20210927155734338.png?lastModify=1646877344)

问题：

**幂等问题**，因为网络调用无法保证请求一定能到达，所以都会有重调机制，因此对于 Try、Confirm、Cancel 三个方法都需要幂等实现，避免重复执行产生错误。

**空回滚问题**，指的是 Try 方法由于网络问题没收到超时了，此时事务管理器就会发出 Cancel 命令，那么需要支持 Cancel  在未执行 Try 的情况下能正常的 Cancel。

**悬挂问题**，这个问题也是指 Try 方法由于网络阻塞超时触发了事务管理器发出了 Cancel 命令，**但是执行了 Cancel 命令之后 Try 请求到了，你说气不气**。

(可以认为是应用层面的2PC，也不依赖数据库。

核心思想是：1.资源检查和预留2.执行资源的操作3.补偿资源检查和预留的操作(反向操作))



### 什么是两阶段2PC协议

2PC是数据一致性协议，与Paxos协议，Raft协议一样，都是在分布式系统下如何保证数据的一致性而衍生出的协议，不过2PC（两阶段提交协议）主要在分布式事务中使用。它将整个事务流程分为两个阶段，准备阶段（Prepare phase）、提交阶段（commit phase）。

```
**准备阶段**（Prepare phase）
事务管理器给每个参与者发送 Prepare 消息，每个数据库参与者在本地执行事务，并写本地的 Undo/Redo 日志，此时事务没有提交。（Undo 日志是记录修改前的数据，用于数据库回滚，Redo 日志是记录修改后的数据，用于提交事务后写入数据文件）

**提交阶段**（commit phase）
如果事务管理器收到了参与者的执行失败或者超时消息时，直接给每个参与者发送回滚（Rollback）消息；否则，发送提交（Commit）消息；参与者根据事务管理器的指令执行提交或者回滚操作，并释放事务处理过程中使用的锁资源。注意：**必须在最后阶段释放锁资源**。
```

`Seata` 也是从两阶段提交演变而来的一种分布式事务解决方案，提供了 **柔性事务**（AT、TCC、SAGA）事务模式 与**刚性事务** XA 事务模式，为用户打造一站式的分布式解决方案，详细可参考官方文档。

```
Seata中定义了三种角色：
```

- Transaction Coordinator（TC）：**事务协调者**，TC是独立的中间件，需要**独立部署**运行，它维护全局事务的运行状态，接收 TM 指令发起全局事务的提交与回滚，负责与 RM 通信协调各各分支事务的提交或回滚。
- Transaction Manager（TM）： **事务管理者**，TM 需要嵌入应用程序中工作，它负责开启一个全局事务，并最终向 TC 发起全局提交或全局回滚的指令。
- Resource Manager（RM）：**资源管理者**，RM控制分支事务，负责分支注册、状态汇报，并接收事务协调器 TC 的指令，驱动分支（本地）事务的提交和回滚。



# Seata

Seata是一个由阿里做背书的分布式事务框架，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。

**AT 模式**

AT 模式是一种无侵入的分布式事务解决方案。阿里seata框架，实现了该模式。

用户只需关注自己的“业务 SQL”，用户的 “业务 SQL” 作为一阶段，Seata 框架会自动生成事务的二阶段提交和回滚操作。

一阶段：

在一阶段，Seata 会拦截“业务 SQL”，首先解析 SQL 语义，找到“业务 SQL”要更新的业务数据，在业务数据被更新前，将其保存成“before image”，然后执行“业务 SQL”更新业务数据，在业务数据更新之后，再将其保存成“after image”，最后生成行锁。以上操作全部在一个数据库事务内完成，这样保证了一阶段操作的原子性。

二阶段提交：

二阶段如果是提交的话，因为“业务 SQL”在一阶段已经提交至数据库， 所以 Seata 框架只需将一阶段保存的快照数据和行锁删掉，完成数据清理即可。

二阶段回滚：

二阶段如果是回滚的话，Seata 就需要回滚一阶段已经执行的“业务 SQL”，还原业务数据。回滚方式便是用“before image”还原业务数据；但在还原前要首先要校验脏写，对比“数据库当前业务数据”和 “after image”，如果两份数据完全一致就说明没有脏写，可以还原业务数据，如果不一致就说明有脏写，出现脏写就需要转人工处理。

AT 模式的一阶段、二阶段提交和回滚均由 Seata 框架自动生成，用户只需编写“业务 SQL”，便能轻松接入分布式事务，AT 模式是一种对业务无任何侵入的分布式事务解决方案。但AT模式存在的不足就是 当操作的数据 是共享型数据，会存在脏写的问题，所以如果是 用户独有数据可以使用AT模式。

**TCC 模式**

**Saga 模式**

这个 Saga 是 Seata 提供的长事务解决方案，适用于业务流程多且长的情况下

![image-20210927161119825](file:///Users/ganxinming/Library/Application%20Support/typora-user-images/image-20210927161119825.png?lastModify=1646877344)

假设有 N 个操作，直接从 T1 开始就是直接执行提交事务，然后再执行 T2，可以看到就是无锁的直接提交，到 T3 发现执行失败了，然后就进入 Compenstaing 阶段，开始一个一个倒回补偿了。

思想就是一开始蒙着头干，别怂，出了问题咱们再一个一个改回去呗。

可以看到这种情况是不保证事务的隔离性的，并且 Saga 也有 TCC 的一样的注意点，需要空补偿，防悬挂和幂等。



**XA模式**

- AT 模式是无侵入的分布式事务解决方案，适用于不希望对业务进行改造的场景，几乎0学习成本。
- TCC 模式是高性能分布式事务解决方案，适用于核心系统等对性能有很高要求的场景。
- Saga 模式是长事务解决方案，适用于业务流程长且需要保证事务最终一致性的业务系统，Saga 模式一阶段就会提交本地事务，无锁，长流程情况下可以保证性能，多用于渠道层、集成层业务系统。事务参与者可能是其它公司的服务或者是遗留系统的服务，无法进行改造和提供 TCC 要求的接口，也可以使用 Saga 模式。
- XA模式是分布式强一致性的解决方案，但性能低而使用较少

# 分布式锁