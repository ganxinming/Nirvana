# 一：CPU读取指令过程

程序是被加载在内存中

cpu组成：控制单元(取址)，逻辑单元(处理逻辑，但是其实最后只有减法)，寄存器(基址，变址)，时钟(协调cpu时间分片)

控制单元先取缓存，没有则取内存

取得指定后，放各种寄存器为后续加减乘除用

逻辑单元，进行处理各种运算从寄存器取值

```
                                                 +-----------------------------------------------+
                                                 |                                               |
                                                 |                                               |
                                                 |                           +-----------------+ |
                                                 |                           |                 | |
+--------------+      +-----------------+        |                           |                 | |
|              |      |                 |        | +----------------+        |                 | |
|              |      |                 |        | |                |        |    各种寄存器   | |
|              +------+                 +----------+                |        |                 | |
|    内存      |      | 一二三级缓存    |        | |  控制单元      +-------->                 | |
|              |      |                 |        | |                |        |                 | |
|              |      |                 |        | |                |        |                 | |
+--------------+      +-----------------+        | +-------+--------+        +-----------------+ |
                                                 |         |                                     |
                                                 | +-------v--------+                            |
                                                 | |                |          +-------------+   |
                                                 | |  逻辑单元      |          |             |   |
                                                 | |                |          |    时钟     |   |
                                                 | |                |          |             |   |
                                                 | +----------------+          +-------------+   |
                                                 +-----------------------------------------------+

```



# 二：操作系统

操作系统：资源管理者和扩展机器。

管态：内核态

目态：用户态（切换到内核态：系统调用，中断，异常）

- **系统调用**：这是用户态主动要求切换到内核态的一种方式。用户进程通过系统调用申请使用操作系统提供的某些服务以便完成工作，比如，调用`fork()`指令实际上就是执行了一个创建新进程的系统调用。系统调用的机制其核心在于**使用了操作系统为用户特别开放的一个中断来实现的，例如`Linux`的`int 80h`中断；
- 
- **外设中断**：当外围设备完成用户请求的操作后，会向`CPU`发出相应的中断信号。这时`CPU`会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序。如果先前执行的是用户态下的指令，那么这个切换过程就是用户态转为内核态。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作；
- **异常**：当`CPU`在执行运行处于用户态的程序时，发生了一些不可知的异常，这个时候就会触发由当前运行进行切换到处理此异常的内核相关程序中，也就是转到了内核态，比如缺页异常；

设备驱动程序：其主要任务是接收上层软件发来的抽象I/O要求，如read或write命令，再把它转换为具体要求后，发送给设备控制器，启动设备去执行。

设备储存器：数据映射和储存的空间。

输入输出的实现：

1.循环轮询IO,造成忙等待。

2.操作完成时中断。

3.使用DMA直接储存器。

##### 进程和线程：

进程：最小的资源管理者。容纳一个程序运行的所有信息的容器。

线程：最小执行单位。用于执行任务。相当于轻量级进程。

进程退出原因：1.正常退出2.异常退出。3.严重错误4.被杀死

进程三种状态：运行，就绪，阻塞。

线程六种状态：新建，可运行，阻塞，等待，限时等待，死亡。

有了进程为什么使用线程？

1.创建快，销毁快2.共享地址空间，合作关系3.多核系统中实现真正意义上的并行。

##### 协程：

一种比线程更加轻量级的存在，可以这样说，一个进程可以有多个线程，而一个线程里面也可以有多个协程。（注：协程是被程序所管理），因为协程的暂停完全由程序控制，线程的阻塞状态是由操作系统内核来进行切换。所以说协程性能得到了很大的提升，不会像线程切换那样消耗资源，协程的开销远远小于线程的开销。
它的应用：
1.Lua语言（Lua从5.0版本开始使用协程，通过扩展库coroutine来实现
2.Python语言（在python 3.5以后，async/await 成为了更好的替代方案）
3.Go语言(Go语言对协程的实现非常强大而简洁，可以轻松创建成百上千个协程并发执行)
4.Java语言
临界区：

1.互斥，任意两个进程不能同时处于临界区。（互斥）

2.不应对任何CPU数量和速度做出假设。	

3.临界区外的程序不应阻塞其他进程。（前进）

4.不得使进程无限期等待进入临界区。（有限等待）

如何控制两个进程访问一个共享的单位用户资源而不发生访问冲突 解决方案：peterson解法（互斥法）。

##### 生产者和消费者：

1.睡眠和唤醒方案（会出现唤醒信号丢失，通过增加唤醒等待位）

2.信号量（PV操作）：一个原子操作，进入一段关键代码前需获得信号量，完成后，才能释放信号量。

用于线程同步：是指在互斥的基础上（大多数情况），通过其它机制实现访问者对资源的有序访问，即访问有顺序。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。

3.互斥锁：访问资源前，判断是否获得锁。

用于线程互斥：互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。

##### 管程：代表共享资源的数据结构，以及由对该共享数据结构实施操作的一组[过程所](https://www.baidu.com/s?wd=过程所&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)组成的资源管理程序，共同构成了一个[操作系统](https://www.baidu.com/s?wd=操作系统&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)的资源管理模块，我们称之为管程。

比如一次只允许一个进程访问的资源或者多个进程只能互斥访问的资源，该访问需要同步操作，比如信号量就是一种方便有效的进程同步机制。但信号量的方式要求每个访问临界资源的进程都具有wait和signal操作。这样使大量的同步操作分散在各个进程中，不仅给系统管理带来了麻烦，而且会因同步操作的使用不当导致死锁。管程就是为了解决这样的问题而产生的。

管程定义了一个数据结构和能为并发进程所执行（在该数据结构上）的一组操作，这组操作能同步进程和改变管程中的数据。
操作系统中管理的各种软件和硬件资源，均可用数据结构抽象地描述其资源特性，==即用少量信息和对该资源所执行的操作来表征该资源，而忽略它们的内部结构和实现细节。利用共享数据结构抽象地表示系统中的共享资源。而把对该共享数据结构实施的操作定义为一组过程，如资源的请求和释放过程request和release。==进程对共享资源的申请、释放和其他操作，都是通过这组过程对共享数据结构的操作来实现的，==这组过程还可以根据资源的情况接受或阻塞进程的访问，确保每次仅有一个进程使用该共享资源==，这样就可以统一管理对共享资源的所有访问，实现临界资源互斥访问。
管程就是这样被请求和释放临界资源的进程所调用。
(==其实就是为了避免，大量的同步操作分散在不同进程，而去统一共享数据结构和对共享结构进行操作的过程==)

##### 进程调度算法：

抢占式和非抢占式。

批处理系统：1.先来先服务2.最短作用优先3.最短剩余时间优先

交互式系统：1.时间片轮转法2.优先级调度3.多级队列(轮转法升级版，第二次时间翻倍)4.彩票调度5.公平共享调度

实时系统：

解决哲学家就餐:PV操作(信号量的值仅能由PV操作来改变)

##### 存储管理：

1.无储存后果：会造成直接访问内存进行破坏。

2.空闲内存管理：1.位图2.链表

##### 处理内存超载的方法：交换技术 vs 虚拟内存

3.虚拟内存：由于内存空间无法容纳程序大小，所以就把硬盘的一部分拿出来当做内存使用。

交换技术：把一个进程完整的调入内存运行一段时间后存放回磁盘，空闲的进程不占用内存，因为他们存放在磁盘

页表：把页面(地址空间)映射成页框（物理内存）。调用不存在页面时，发生缺页中断。

##### 转换检测缓冲区 （TLB）/快表,就直接将页框号从TLB取出而不去访问页表.TLB失效：

- 软失效：一个页面访问 在内存中却不在 TLB 中，只要更新 TLB 就可以了，不会产生磁盘 IO，处理时间很短；
- 硬失效：页面本身既不在内存也不在 TLB，需要磁盘存取来装入该页面，耗费时间长

##### 页面置换算法：LRU,NRU,FIFO,clock，第二次机会(状态位清0置末尾)，工作集时钟

##### 磁盘调度算法：最短寻道优先SSF(永远只看离磁头近的),电梯算法(改)

### 死锁：

四个条件：互斥，保持和请求，循环等待，不可抢占。

处理方法：

1.鸵鸟算法

2.死锁检测（有向图里寻找环路）和恢复(1.抢占恢复，资源抢夺2.回滚恢复，回滚最近点3.杀死进程)：

3.死锁避免：资源轨迹图，银行家算法。

4.破坏四个死锁条件之一。





{
  "orderNo": 0,
  "customerNo": 0,
  "customerMobile": "",
  "getOffTime": 0,
  "context": {}
}



```
curl -H "Content-Type:application/json" -X POST --data "{  \"orderNo\": 123123123,  \"customerNo\": 456456456,  \"customerMobile\": \"1234567890\",  \"getOffTime\": 1645778484585,  \"context\": {\"customerNo\":123}}" http://localhost:8021/risk-console-center/redis/addStopBill

curl localhost:8021/risk-console-center/redis/addStopBill -X POST -d 'orderNo=123123123'

curl localhost:8021/risk-console-center/redis/addStopBill -X POST -d '{"orderNo": 123312}' --header "Content-Type: application/json"

curl -H "Content-Type: application/json" -X POST  --data '{  "orderNo": 123123123,  "customerNo": 456456456,  "customerMobile": "1234567890",  "getOffTime": 1645778484585,  "context": {"customerNo":123}}' http://localhost:8021/risk-console-center/redis/addStopBill

```

20 50

去除增长率

运营效率 20 50