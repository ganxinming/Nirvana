# ElasticSearch

基于lucene做了一些封装和增强。

(Luncene是信息检索工具包)

es是一个开源的高扩展分布式全文搜索引擎。近乎实时储存，检索数据。可扩展上百台服务器，处理PB(大数据)级别数据。



### 目的

通过对Lucene的封装，隐藏了Lucene的复杂性，取而代之的提供一套简单一致的 RESTful API。

通过简单的RestFul API(/post/delete/put/get)操作，实现快速搜索。

- 一个分布式的实时文档存储，每个字段可以被索引与搜索。
- 一个分布式实时分析搜索引擎。
- 能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据。

## 集群

ES的集群搭建很简单，不需要依赖第三方协调管理组件，自身内部就实现了集群的管理功能。ES集群由一个或多个Elasticsearch节点组成，每个节点配置相同的 `cluster.name` 即可加入集群，默认值为 “elasticsearch”。确保不同的环境中使用不同的集群名称，否则最终会导致节点加入错误的集群。

一个Elasticsearch服务启动实例就是一个节点（Node）。节点通过`node.name`来设置节点名称，如果不设置则在启动时给节点分配一个随机通用唯一标识符作为名称。

（==默认就实现了集群，只要cluster.name一样就是一个集群，比solr方便多了==）

#### 发现机制

那么有一个问题，ES内部是如何通过一个相同的设置`cluster.name` 就能将不同的节点连接到同一个集群的？答案是`Zen Discovery`。

Zen Discovery是Elasticsearch的内置默认发现模块（发现模块的职责是发现集群中的节点以及选举master节点）。

#### 节点的角色

每个节点既可以是**候选主节点** 也可以是**数据节点** ，通过在配置文件`../config/elasticsearch.yml`中设置即可，默认都为`true`。

```
Copynode.master: true  //是否候选主节点
node.data: true    //是否数据节点
```

**1.数据节点** 

负责数据的存储和相关的操作，例如对数据进行增、删、改、查和聚合等操作，所以数据节点（data节点）对机器配置要求比较高，对CPU、内存和I/O的消耗很大。通常随着集群的扩大，需要增加更多的数据节点来提高性能和可用性。

**2.候选主节点** 

可以被选举为主节点（master节点），集群中只有候选主节点才有选举权和被选举权，其他节点不参与选举的工作。主节点负责创建索引、删除索引、跟踪哪些节点是群集的一部分，并决定哪些分片分配给相关的节点、追踪集群中节点的状态等，稳定的主节点对集群的健康是非常重要的。

#### 脑裂现象

同时如果由于网络或其他原因导致集群中选举出多个Master节点，使得数据更新时出现不一致，这种现象称之为**脑裂** ，即集群中不同的节点对于master的选择出现了分歧，出现了多个master竞争。

### 概述：

Es是面向文档。 一切都是json(仅支持json)

关系型数据库的对比

| DB              | ES                        |
| --------------- | ------------------------- |
| 数据库 database | 索引(indices)             |
| 表 table        | Types（类型，过时）       |
| 行rows          | Documents(文档，一条数据) |
| 字段 columns    | Fields                    |

### 物理设计

##### es将每个索引划分多个分片，分片能在不同集群转移。一个人就是一个集群，默认的集群名称就是elasticSearch

### 分片（Shards）（相当于天生支持分表）

##### ES支持PB级全文搜索，当索引上的数据量太大的时候，ES通过水平拆分的方式将一个索引上的数据拆分出来分配到不同的数据块上，拆分出来的数据库块称之为一个**分片** 。

这类似于MySql的分库分表，只不过Mysql分库分表需要借助第三方组件而ES内部自身实现了此功能。

==在一个多分片的索引中写入数据时，通过路由来确定具体写入哪一个分片中，所以在创建索引的时候需要指定分片的数量，并且分片的数量一旦确定就不能修改。==

分片的数量和下面介绍的副本数量都是可以通过创建索引时的`settings`来配置，ES默认为一个索引创建5个主分片, 并分别为每个分片创建一个副本。

```
CopyPUT /myIndex
{
   "settings" : {
      "number_of_shards" : 5,
      "number_of_replicas" : 1
   }
}
```

ES通过分片的功能使得索引在规模上和性能上都得到提升，每个分片都是Lucene中的一个索引文件，每个分片必须有一个主分片和零到多个副本。

（==将数据分片是为了提高可处理数据的容量和易于进行水平扩展，为分片做副本是为了提高集群的稳定性和提高并发量==）



### 副本（Replicas）提升可用性和持久性

副本就是对分片的Copy，每个主分片都有一个或多个副本分片，当主分片异常时，副本可以提供数据的查询等操作。==主分片和对应的副本分片是不会在同一个节点上的，所以副本分片数的最大值是 n -1（其中n为节点数）。==

对文档的新建、索引和删除请求都是写操作，必须在主分片上面完成之后才能被复制到相关的副本分片，ES为了提高写入的能力这个过程是并发写的，同时为了解决并发写的过程中数据冲突的问题，ES通过乐观锁的方式控制，每个文档都有一个 _version （版本）号，当文档被修改时版本号递增。一旦所有的副本分片都报告写成功才会向协调节点报告成功，协调节点向客户端报告成功。

（==通过乐观锁控制副本的写入，每个文档都有一个版本号==）



> ### 类型

类型是文档的逻辑容器，想表格就是行的容器。

> ### 索引

就是数据库，索引是一个非常大的文档集合。将数据分散到不同分片，每个分片，有主分片和从分片，主从绝对不在同一节点。每个节点就是一个es进程。一个分片就是一个lucene索引，一个包含倒排索引的文件目录。所以不扫描全部文档，也能知道哪些数据包含关键字。

![image-20201111231046066](../../../Desktop/TyporaBlogMAC/图/image-20201111231046066.png)

> ### 文档

一个文档包含对应的key和value对应的字段。可以是有层次，复杂的文档(json对象)



# 操作

##### 新建索引/插入数据：

http://115.159.202.204:9200/test1/type1/1 PUT请求（数据放在json里）

/新建索引名 test1/类型type1/文档id

类型默认_doc

##### 更新数据：

http://115.159.202.204:9200/test3/_doc/1  PUT请求

/索引名 test3/类型_doc/文档id  

##### 新版更新http://115.159.202.204:9200/test3/_doc/1/_update  POST请求（后面加个标识）

区别：PUT会将此次所提提交的数据全部覆盖原本的，而新版只修改提交修改的值。

##### 删除数据：

DELETE 请求

根据路径进行删除，如果是索引删除整个索引，如果某个文档删除文档

**查询数据：**

http://115.159.202.204:9200/test3/_doc/1  GET请求

**简单条件查询** http://115.159.202.204:9200/test3/_doc/_search?q=class:1234

_search?q=字段名:值

**复杂查询** 

GET请求带着请求体

```
{
    "query":{
        "match":{
            "name":"abc"
        }
    },
    "_source":["name"], //展示需要显示的字段，默认全部字段展示
    "sort":[					 //按字段排序
    	{
    		"age" : "asc"
    	}
    ],
    "from" : 0, //分页，跟limit参数类似
    "size" : 2
    
}
```

**must**相当于and，多个条件查询。**should**相当于or。**must_not**不是某个值相当于not.

**filter**可以进行过滤

```
{
    "query":{
        "bool":{
        	"must":[
        			{
        			"match":{
            			"name":"abc"
      			 		 }
        			},
        			{
        			"match":{
            			"age":18
      			 		 }
        			}
        	],
        	"filter":{
        		"range":{
        			"age":{
        				"gt":10,
        				"lt":20
        			}
        		}
        	}
        }
    }
}
```

#### 精确查询

- term(精确匹配)
- match(使用分词器进行解析，利用倒排索引查)

(Keyword类型字段不会被分词器解析，换句话只能精确查，text：存储数据时候，会自动分词，并生成索引。)

#### 高亮查询 

相当于对搜索的高亮字段加了个html标签，当然也可以自定义高亮显示标签。

```
{
    "query":{
        "match":{
            "name":"abc"
        }
    },
    "highlight":{
    	"fields":{
    		"name":{}
    	}
    }
}
```



# 2.ELK

##### elasticSearch，logstash，kibana。

搜集数据->清洗数据->分析展示







customerAllSuccessHermesOrderCount

customerAllSuccessHermesOrderCount

```
private Boolean is_success;
private Integer code;
private String msg;
private T data;
```