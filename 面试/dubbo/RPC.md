RPC

远程过程调用协议：解决不同计算机之间服务调用的的问题。(像调本地服务一样，屏蔽网络通信问题)

RPC：适用于服务和服务之间。(适用于内部)

HTTP：用户和服务之间。

**1、**服务消费者（client客户端）通过调用本地服务的方式调用需要消费的服务；

**2、**客户端存根（client stub）接收到调用请求后负责将方法、入参等信息序列化（组装）成能够进行网络传输的消息体；

**3、**客户端存根（client stub）找到远程的服务地址，并且将消息通过网络发送给服务端；

**4、**服务端存根（server stub）收到消息后进行解码（反序列化操作）；

**5、**服务端存根（server stub）根据解码结果调用本地的服务进行相关处理；

**6、**本地服务执行具体业务逻辑并将处理结果返回给服务端存根（server stub）；

**7、**服务端存根（server stub）将返回结果重新打包成消息（序列化）并通过网络发送至消费方；

**8、**客户端存根（client stub）接收到消息，并进行解码（反序列化）；

**9、**服务消费方得到最终结果；

(实际上我们只看到1，9步，其他都是透明的)

其实看着过程还是容易想到的技术【动态代理，序列化，反序列化，NIO(建立连接),服务地址注册和发现】



主流RPC框架：

dubbo，Thrift，GRPC，Hessian等



### 1.为什么要自定义传输协议

用http不可以吗？

- 1.0版本支持半双工通信
- 不支持服务端主动推送
- 有效负载少，原本只是简单传个方法名，参数，现在却要带个header

