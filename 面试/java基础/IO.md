

# 	BIO/NIO/AIO：

##### 同步和异步：当我们进行同步操作时，后续的任务是等待当前调用返回，才会进行下一步，异步则相反。

##### `阻塞`和`非阻塞`针对的是操作io后是否立即得到的返回结果而言的。阻塞：一直等待。非阻塞：立刻返回结果。



## 同步和异步

同步/异步关注的是消息通信机制。

**同步**：所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。等前一件做完了才能做下一件事。

**异步**：异步的概念和同步相对。当一个异步过程调用发出后，调用者若不能立刻得到结果，此时可以直接返回然后执行其他任务，等到获得了结果之后通过状态、通知或者回调等手段通知调用者。

同步、异步一般发生在**不同的线程/进程之间**，如`Thread1`和`Thread2`是同步执行还是异步执行的。

## 阻塞和非阻塞

阻塞和非阻塞关注的是程序在等待调用结果时的状态。

**阻塞**： 阻塞调用是指调用返回之前，当前线程会被挂起，只有当调用得到结果后才返回。

**非阻塞**：与阻塞相反，非阻塞调用是指在不能立即得到结果之前，该函数不会将当前线程阻塞，立即返回或者循环检查。

(==同步多数情况下意味着阻塞，但是也可能非阻塞，比如轮询。异步多数情况下意味着非阻塞，但也可能阻塞，比如向线程池提交任务，使用Future.get()，假如任务未完成，阻塞获取结果。阻塞和非阻塞只是同步和异步的一种属性。==)



## BIO:

同步阻塞式IO,基于字节流，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如;socket通过在while循环中服务端会调用accept方法等待接收客户端的连接请求，一旦接收到一个连接请求，就可以建立通信套接字在这个通信套接字上进行读写操作，此时不能再接收其他客户端连接请求，只能等待同当前连接的客户端的操作执行完成。 如果BIO要能够同时处理多个客户端请求，就必须使用多线程，即每次accept阻塞等待来自客户端请求，一旦受到连接请求就建立通信套接字同时开启一个新的线程来处理这个套接字的数据读写请求，然后立刻又继续accept等待其他客户端连接请求。执行while循环，当发现有人接入了accept，就开启一个新的线程，或者从线程池中取一个线程为他服务,如果没有线程了，则会一直等待或者遭到拒绝请求。

##### 主要用于：数据间的传输。分为管道流和节点流。



## NIO:

同步非阻塞 IO ，基于Channel、Selector、Buffer。关键是采用了Reactor事件驱动的思想来实现了一个多路转换器，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接 “有I/O请求” 时才启动一个线程进行处理。 NIO的最重要的地方是当一个连接创建后，不需要对应一个线程，这个连接会被注册到多路复用器上面，所以所有的连接只需要一个线程就可以搞定，当这个线程中的多路复用器进行轮询的时候，发现连接上有请求的话，才开启一个线程进行处理，也就是一个请求一个线程模式。

NIO与BIO最大的区别就是只需要开启一个线程就可以处理来自多个客户端的IO请求事件。

BIO是一个连接一个线程。

NIO是一个请求一个线程。

AIO是一个有效请求一个线程。

## AIO:

##### 异步非阻塞式IO，异步 IO 操作基于事件和回调机制，应用操作直接返回，而不会阻塞在那里，当后台处理完成，操作系统会通知相应线程进行后续工作。

与NIO不同，当进行读写操作时，只须直接调用API的read或write方法即可。这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入read方法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将write方法传递的流写入完毕时，操作系统主动通知应用程序。  即可以理解为，read/write方法都是异步的，完成后会主动调用回调函数。

- BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。
- NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。
- AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。

#### socket和websocket区别：

WebSocket：同HTTP一样也是应用层的协议，但是它是一种**双向通信协议**，是建立在TCP之上的。Browser/Client Agent 都能主动的向对方发送或接收数据。

Socket：是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。

#### netty：它对JDK中的NIO做了封装和优化，提供了更好的性能的同时，降低了使用的难度。



# IO模型

`IO`一般分为**磁盘IO**和**网络IO**，这里我们主要关注**网络IO**。

## 五种IO模型

**阻塞io(同步io)：**

阻塞，顾名思义，当进程在等待数据时，若该数据一直没有产生，则该进程将一直等待，直到等待的数据产生为止，这个过程中进程的状态是阻塞的。

<img src="../../../Library/Application Support/typora-user-images/image-20210926164028697.png" alt="image-20210926164028697" style="zoom:33%;" />

(recvfrom发生一次系统调用，进行内核到用户空间的数据复制)

如上图所示，在linux中，用户态进程调用recvfrom系统调用接收数据，当前内核中并没有准备好数据，该用户态进程将一直在此等待，不会进行其他的操作，待内核态准备好数据，将数据从内核态拷贝到用户空间内存，然后recvfrom返回成功的指示，此时用户态进行才解除阻塞的状态，处理收到的数据。

> 从上述过程可以看出，用户态接收内核态数据的时候，主要有两个过程：内核态获得数据-->将数据从内核态的内存空间中复制到用户态进程的缓冲区中

**非阻塞io(同步io)：**

　　在非阻塞式I/O模型中，当进程等待内核的数据，而当该数据未到达的时候，进程会不断询问内核，直到内核准备好数据。

<img src="../../../Library/Application Support/typora-user-images/image-20210926164257842.png" alt="image-20210926164257842" style="zoom:33%;" />

如上图，用户态进程调用recvfrom接收数据，当前并没有数据报文产生，此时recvfrom返回EWOULDBLOCK，用户态进程会一直调用recvfrom询问内核，待内核准备好数据的时候，之后用户态进程不再询问内核，待数据从内核复制到用户空间，recvfrom成功返回，用户态进程开始处理数据。

> 需要注意的是，当数据从内核复制到用户空间中的这一段时间中，用户态进程是处于阻塞的状态的。
>
> 非阻塞式I/O模型，个人觉得这个名字可能有点混淆，并不是和阻塞式模型是完全对立的，不是说进程等不到数据，就去做别的事情，恰恰进程这个时候一直在原地等待数据的到来，与阻塞式模型不同的是，非阻塞相当于进程一直在敲门问“数据好了么，快给我”，然后房门后的人说“没有准备好，请稍后！”，这个过程是一种轮询的状态，而阻塞式是佛系的态度，敲了一次门，房门后的人没有给任何回应，于是就去睡觉，啥都不做，直到房门后的人做出响应叫醒他，进程才去做下一步动作。
>
> (所以其实正好对应了前面说的，阻塞和非阻塞看的是返回结果的状态)

**io复用(同步io)：**　

　　I/O是指网络I/O,多路指多个TCP连接(即socket或者channel）,复用指复用一个或几个线程。意思说一个或一组线程处理多个连接。比如课堂上学生做完了作业就举手，老师就下去检查作业。(对一个IO端口，两次调用，两次返回，比阻塞IO并没有什么优越性；关键是能实现同时对多个IO端口进行监听，可以同时对多个读/写操作的IO函数进行轮询检测，直到有数据可读或可写时，才真正调用IO操作函数。)　(==单线程监听多个IO端口==)

<img src="../../../Library/Application Support/typora-user-images/image-20210926164622139.png" alt="image-20210926164622139" style="zoom:33%;" />

如上图所示，用户态进程采用select的方法，通过select可以等待多个不同类型的消息，如果其中有一个类型的消息准备好，则select会返回信息，然后用户态进程调用recvfrom接收数据。(select去监听连接的建立，读和写的请求)

> 可以将select复用机制看作是一个描述符集合的管理，进程通过向这个集合中放入不同的描述符，用来等待不同的消息产生，然后通过select统一的进行管理，让其可以同时等待这个集合中任意一个事件的产生。
>
> I/O复用和阻塞式I/O很相似，不同的是，I/O复用等待多类事件，阻塞式I/O只等待一类事件，另外，在I/O复用中，会产生两个系统调用（如上图，select和recvfrom），而阻塞式I/O只产生一个系统调用。那么这就涉及到具体的性能问题，当只存在一类事件的时候，使用阻塞式I/O模型的性能会更好，当存在多种不同类型的事件时，I/O复用的性能要好的多，因为阻塞式I/O模型只能监听一类事件，所以这个时候需要使用多线程进行处理。

#### 在linux中，关于多路复用的使用，有三种不同的API，select、poll和epoll。

select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。

**但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的**

(不详细描述了，有点复杂，select和poll基本相同，epoll最强)



**信号驱动io(同步io)：**

在信号驱动式I/O模型中，与阻塞式和非阻塞式有了一个本质的区别，那就是用户态进程不再等待内核态的数据准备好，直接可以去做别的事情。

　　事先发出一个请求，当有数据后会返回一个标识回调，这时你可以去请求数据。好比银行排号，当叫到你的时候，你就可以去处理业务了(复制数据时阻塞)。



<img src="../../../Library/Application Support/typora-user-images/image-20210926164933357.png" alt="image-20210926164933357" style="zoom:33%;" />

如上图所示，当需要等待数据的时候，首先用户态会向内核发送一个信号，告诉内核我要什么数据，然后用户态就不管了，做别的事情去了，而当内核态中的数据准备好之后，内核立马发给用户态一个信号，说”数据准备好了，快来查收“，用户态进程收到之后，立马调用recvfrom，等待数据从内核空间复制到用户空间，待完成之后recvfrom返回成功指示，用户态进程才处理别的事情。

(只是进行数据准备好了就通知，而不是完成了通知)

> 通过上面的图，可以看出信号驱动式I/O模型有种异步操作的赶脚，但是在将数据从内核复制到用户空间这段时间内用户态进程是阻塞的

**异步io：**

　　发出请求就返回，剩下的事情会异步自动完成，不需要做任何处理。好比有事秘书干，自己啥也不用管。　　

<img src="../../../Library/Application Support/typora-user-images/image-20210926165123030.png" alt="image-20210926165123030" style="zoom:33%;" />

异步I/O模型相对于信号驱动式I/O模型就更彻底了。

如上图，首先用户态进程告诉内核态需要什么数据（上图中通过aio_read），然后用户态进程就不管了，做别的事情，内核等待用户态需要的数据准备好，然后将数据复制到用户空间，此时才告诉用户态进程，”数据都已经准备好，请查收“，然后用户态进程直接处理用户空间的数据。

> 在复制数据到用户空间这个时间段内，用户态进程也是不阻塞的

<img src="../../../Library/Application Support/typora-user-images/image-20210926165206404.png" alt="image-20210926165206404" style="zoom:50%;" />

总结：

1.说起IO，底层一定想起系统调用recvfrom，对数据进行准备和复制。

2.任何数据的读取，需要有这两步，内核态数据准备，内核复制到用户态。

2.五种模式的区别无非就是，请求方是否等待和轮询(是否完成准备和复制)，响应方是否主动通知。

(

1.阻塞：从建立连接，发起系统调用，数据复制 一直阻塞。(发生了recvfrom系统调用)

2.非阻塞：发起系统调用，直接得到一个未完成的结果，然后不然轮询是否复制完成，完成后(发生了recvfrom系统调用)

3.IO复用：单(组)线程监听所有连接的建立和读写请求，去处理他们的请求。(发生了select系统调用和recvfrom)

4.信号驱动IO：建立信号处理程序，等待数据准备完成的信号，再来recvfrom，进行数据复制。(发生信号通知调用和recvfrom)

5.异步IO：直接告知需要的数据，直接等待完成数据复制。

)