# 一：网络

##### 主机之间的通信方式：

- 客户-服务器（C/S）：客户是服务的请求方，服务器是服务的提供方。
- 对等（P2P）：不区分客户和服务器。   

##### 三种交换方式：电路交换，报文交换，分组交换

电路交换是以电路连接为目的的交换方式，通信之前要在通信双方之间建立一条被双方独占的物理通道。

**电路交换的三个阶段**：

（1）建立连接	（2）通信	（3）释放连接

优点：由于通信线路为通信双方用户专用，数据直达，所以传输数据的时延非常小。

缺点：电路交换平均连接建立时间对计算机通信来说较长（适用于传输大数据，传输时间大于信道建立时间

##### 分组交换：

分组交换是以分组为单位进行传输和交换的，它是一种存储——转发交换方式，即将到达交换机的分组先送到存储器暂时存储和处理，等到相应的输出电路有空闲时再送出。

优点：（1）分组交换不需要为通信双反预先建立一条专用的通信线路，不存在连接建立时延，用户可随时发送。

缺点：（1）由于数据进入交换节点后要经历存储转发这一过程，从而引起的转发时延（包括接受分组、检验正确性、排队、发送时间等），而且网络的通信量越大，造成的时延就越大，实时性较差。

##### 时延：

总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延

### 计算机网络体系结构

## 五层协议

- **应用层** ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。(报文)
- **传输层** ：为进程提供通用数据传输服务。TCP 主要提供完整性服务，UDP 主要提供及时性服务(用户数据报)
- **网络层** ：把传输层传递下来的报文段或者用户数据报封装成IP数据报。为主机提供数据传输服务(数据报)(IP,IPV4,IPV6,ICMP:发送主机无法确定数据报是否到达目标主机ICMP报文分为出错报告报文和查询报文两种,IGMP:建立和管理多播组)
- **数据链路层** ：数据链路层把网络层传下来的数据报封装成帧。链路层协议就是为同一链路的主机提供数据传输服务并供错误检测和纠正，以确保数据的可靠传输。（帧）(CSMA/CD,ppp,HDLC)
- **物理层** ：它的主要作用是传输比特流。(比特)

OSI七层协议：应用层，表示层，会话层，传输层，网络层，数据链路层，物理层。

TCP/IP四层协议：网络接口层，网际层，传输层，应用层。

### HTTP:

URI(统一资源标识符) 包含 URL(统一资源定位符) 和 URN(统一资源名称)。

![1566018215417](C:\Users\12714\AppData\Roaming\Typora\typora-user-images\1566018215417.png)

HTTP主要方法：

get：主要用于获取资源。

post：主要用于传输数据.

head:获取报文首部。

put：上传文件。

delete：删除文件，和put相反。

#### HTTP状态码：

1xx:接收的请求正在处理,可以忽略。100(正常)101,协议转换。

2xx:表示成功处理请求。200(OK)。204(no content,成功处理请求，但无返回内容)

3xx:表示重定向，需进一步操作。localtion+302(临时重定向)，301(永久重定向)

4xx:(客户端错误)请求出错，服务器无法处理请求。403(服务器拒绝请求)404.

5xx:(服务端错误)服务器内部处理请求出错。500(服务器错误)503(服务器不可用:停机维护)

#### HTTP是无状态，无连接协议：

#####  短连接与长连接

短连接：http通信进行TCP握手连接，响应后断开连接。

长连接：建立一次连接，进行多次http通信。

http1.1，基于Connection : Keep-Alive，默认长连接。如关闭：Connection : close。

#### 无状态：

对事物没有记忆能力，所以才有了cookie。之所以设计成无状态，使他能够处理更多的事务。

cookie：用于客户端存储数据，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。

session：客户端存储数据，一般依赖cookie存储的sessionId，如果禁用cookie，使用URL重写解决。

#### HTTPS:

HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer安全套接字层）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。

SSL介于应用层和TCP层之间。应用层数据不再直接传递给传输层，而是传递给SSL层，SSL层对从应用层收到的数据进行加密，并增加自己的SSL头。

SSL协议可分为三层：

SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。

==主要依靠RSA非对称加密(对称秘钥协商)，对称加密(对称加密加密明文)，MD5哈希散列函数(完整性校验)。==

SSL记录协议（SSL Record Protocol）：记录协议向SSL连接提供两个服务：

（1）保密性：使用握手协议定义的秘密密钥实现

（2）完整性：握手协议定义了MAC，用于保证消息完整性

**SSL警报协议**：用于处理错误，如果是致命错误，则算法立即关闭SSL连接

使用握手协议协商加密和MAC算法以及保密密钥 ，使用记录协议对交换的数据进行加密和签名，使用警报协议定义数据传输过程中，出现问题如何去解决。



#### RSA作用：

1、对称秘钥协商

用普通的秘钥传输，可能被劫持，秘钥就泄露了。可以利用RSA，服务器将公钥给客户端，客户端定制一个对称加密秘钥，使用公钥加密，传输给服务器，服务器用私钥解密。之后就可以利用这个对称秘钥进行加密了。

（但是这种方式无法预防中间人攻击，中间人既做服务端，又做客户端，在中间通信。这里其实最重要的问题是，客户端无法感知和自己通信的是不是真实的服务端【因为不知道这个公钥是不是真实的服务端的】，所以引入了CA证书机构）

2、数字签名

用CA私钥对信息摘要(明文消息加密后)进行加密得到的数字，CA公钥就放在本地证书管理器中，里面有"受信任的根证书颁发机构"列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。

(所以基本认定CA公钥不可伪造，所有人都能拿的到)

#### CA机构：

潜意识可以直接认为就是为了解决，==保证认可这个公钥是真实的服务器,保证真实性，不会中间人篡改==

所以颁发数字证书，数字证书里包含服务端的公钥，客户端可以用CA公钥解开数字证书，拿到服务端公钥。

![image-20211009085520415](../../../Library/Application Support/typora-user-images/image-20211009085520415.png)

经过上面的了解可以基本归纳了一次通信的过程：A客户端，B服务端

A和B建立HTTPS连接进行通信

A拿到B的数字证书，使用CA公钥解密，拿到B的公钥

使用B的公钥加密A的对称公钥，发送给B，这样B可以用私钥解密，得到A的对称公钥了。(完成对称秘钥的交换)





##### HTTP1.0,1.1,2.0区别：

1.0：无状态、无连接

1.1：持久化连接，keepalive

2.0：压缩头部(没压缩之前，头部数据量很大)，多路复用(一个tcp连接实现多个http请求)，服务器推送(主动推送)

#### 三次握手和四次挥手：

为什么不是两次？

客户端发送的连接请求，并没有消失，而是在某个网络节点长时间滞留了，以至于延迟到连接释放之后才打到服务器。原本这个早已失效的报文段，但是服务器误认为是客服端发送的新的请求，于是就向客户端发送确定的报文段，同意建立连接，若不采用三次握手，新的连接就建立了（莫名其妙就建立的连接）。由于客户端并没有发送连接请求，不会理睬服务器的请求，浪费服务器的资源。  



## 同步和异步

同步/异步关注的是消息通信机制。

**同步**：所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。等前一件做完了才能做下一件事。

**异步**：异步的概念和同步相对。当一个异步过程调用发出后，调用者若不能立刻得到结果，此时可以直接返回然后执行其他任务，等到获得了结果之后通过状态、通知或者回调等手段通知调用者。

同步、异步一般发生在**不同的线程/进程之间**，如`Thread1`和`Thread2`是同步执行还是异步执行的。

## 阻塞和非阻塞

阻塞和非阻塞关注的是程序在等待调用结果时的状态。

**阻塞**： 阻塞调用是指调用返回之前，当前线程会被挂起，只有当调用得到结果后才返回。

**非阻塞**：与阻塞相反，非阻塞调用是指在不能立即得到结果之前，该函数不会将当前线程阻塞，而是立即返回。

(同步多数情况下意味着阻塞，但是也可能非阻塞，比如轮询。异步多数情况下意味着非阻塞，但也可能阻塞，比如向线程池提交任务，使用Future.get()，假如任务未完成，阻塞获取结果。阻塞和非阻塞只是同步和异步的一种属性。)

# IO模型

`IO`一般分为**磁盘IO**和**网络IO**，这里我们主要关注**网络IO**。

## 五种IO模型

**阻塞io(同步io)：**

阻塞，顾名思义，当进程在等待数据时，若该数据一直没有产生，则该进程将一直等待，直到等待的数据产生为止，这个过程中进程的状态是阻塞的。

<img src="../../../Library/Application Support/typora-user-images/image-20210926164028697.png" alt="image-20210926164028697" style="zoom:33%;" />

(recvfrom发生一次系统调用，进行内核到用户空间的数据复制)

如上图所示，在linux中，用户态进程调用recvfrom系统调用接收数据，当前内核中并没有准备好数据，该用户态进程将一直在此等待，不会进行其他的操作，待内核态准备好数据，将数据从内核态拷贝到用户空间内存，然后recvfrom返回成功的指示，此时用户态进行才解除阻塞的状态，处理收到的数据。

> 从上述过程可以看出，用户态接收内核态数据的时候，主要有两个过程：内核态获得数据-->将数据从内核态的内存空间中复制到用户态进程的缓冲区中

**非阻塞io(同步io)：**

　　在非阻塞式I/O模型中，当进程等待内核的数据，而当该数据未到达的时候，进程会不断询问内核，直到内核准备好数据。

<img src="../../../Library/Application Support/typora-user-images/image-20210926164257842.png" alt="image-20210926164257842" style="zoom:33%;" />

如上图，用户态进程调用recvfrom接收数据，当前并没有数据报文产生，此时recvfrom返回EWOULDBLOCK，用户态进程会一直调用recvfrom询问内核，待内核准备好数据的时候，之后用户态进程不再询问内核，待数据从内核复制到用户空间，recvfrom成功返回，用户态进程开始处理数据。

> 需要注意的是，当数据从内核复制到用户空间中的这一段时间中，用户态进程是处于阻塞的状态的。
>
> 非阻塞式I/O模型，个人觉得这个名字可能有点混淆，并不是和阻塞式模型是完全对立的，不是说进程等不到数据，就去做别的事情，恰恰进程这个时候一直在原地等待数据的到来，与阻塞式模型不同的是，非阻塞相当于进程一直在敲门问“数据好了么，快给我”，然后房门后的人说“没有准备好，请稍后！”，这个过程是一种轮询的状态，而阻塞式是佛系的态度，敲了一次门，房门后的人没有给任何回应，于是就去睡觉，啥都不做，直到房门后的人做出响应叫醒他，进程才去做下一步动作。
>
> (所以其实正好对应了前面说的，阻塞和非阻塞看的是返回结果的状态)

**io复用(同步io)：**　

　　I/O是指网络I/O,多路指多个TCP连接(即socket或者channel）,复用指复用一个或几个线程。意思说一个或一组线程处理多个连接。比如课堂上学生做完了作业就举手，老师就下去检查作业。(对一个IO端口，两次调用，两次返回，比阻塞IO并没有什么优越性；关键是能实现同时对多个IO端口进行监听，可以同时对多个读/写操作的IO函数进行轮询检测，直到有数据可读或可写时，才真正调用IO操作函数。)　(==单线程监听多个IO端口==)

<img src="../../../Library/Application Support/typora-user-images/image-20210926164622139.png" alt="image-20210926164622139" style="zoom:33%;" />

如上图所示，用户态进程采用select的方法，通过select可以等待多个不同类型的消息，如果其中有一个类型的消息准备好，则select会返回信息，然后用户态进程调用recvfrom接收数据。(select去监听连接的建立，读和写的请求)

> 可以将select复用机制看作是一个描述符集合的管理，进程通过向这个集合中放入不同的描述符，用来等待不同的消息产生，然后通过select统一的进行管理，让其可以同时等待这个集合中任意一个事件的产生。
>
> I/O复用和阻塞式I/O很相似，不同的是，I/O复用等待多类事件，阻塞式I/O只等待一类事件，另外，在I/O复用中，会产生两个系统调用（如上图，select和recvfrom），而阻塞式I/O只产生一个系统调用。那么这就涉及到具体的性能问题，当只存在一类事件的时候，使用阻塞式I/O模型的性能会更好，当存在多种不同类型的事件时，I/O复用的性能要好的多，因为阻塞式I/O模型只能监听一类事件，所以这个时候需要使用多线程进行处理。

#### 在linux中，关于多路复用的使用，有三种不同的API，select、poll和epoll。

select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。

**但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的**

(不详细描述了，有点复杂，select和poll基本相同，epoll最强)



**信号驱动io(同步io)：**

在信号驱动式I/O模型中，与阻塞式和非阻塞式有了一个本质的区别，那就是用户态进程不再等待内核态的数据准备好，直接可以去做别的事情。

　　事先发出一个请求，当有数据后会返回一个标识回调，这时你可以去请求数据。好比银行排号，当叫到你的时候，你就可以去处理业务了(复制数据时阻塞)。



<img src="../../../Library/Application Support/typora-user-images/image-20210926164933357.png" alt="image-20210926164933357" style="zoom:33%;" />

如上图所示，当需要等待数据的时候，首先用户态会向内核发送一个信号，告诉内核我要什么数据，然后用户态就不管了，做别的事情去了，而当内核态中的数据准备好之后，内核立马发给用户态一个信号，说”数据准备好了，快来查收“，用户态进程收到之后，立马调用recvfrom，等待数据从内核空间复制到用户空间，待完成之后recvfrom返回成功指示，用户态进程才处理别的事情。

(只是进行数据准备好了就通知，而不是完成了通知)

> 通过上面的图，可以看出信号驱动式I/O模型有种异步操作的赶脚，但是在将数据从内核复制到用户空间这段时间内用户态进程是阻塞的

**异步io：**

　　发出请求就返回，剩下的事情会异步自动完成，不需要做任何处理。好比有事秘书干，自己啥也不用管。　　

<img src="../../../Library/Application Support/typora-user-images/image-20210926165123030.png" alt="image-20210926165123030" style="zoom:33%;" />

异步I/O模型相对于信号驱动式I/O模型就更彻底了。

如上图，首先用户态进程告诉内核态需要什么数据（上图中通过aio_read），然后用户态进程就不管了，做别的事情，内核等待用户态需要的数据准备好，然后将数据复制到用户空间，此时才告诉用户态进程，”数据都已经准备好，请查收“，然后用户态进程直接处理用户空间的数据。

> 在复制数据到用户空间这个时间段内，用户态进程也是不阻塞的

<img src="../../../Library/Application Support/typora-user-images/image-20210926165206404.png" alt="image-20210926165206404" style="zoom:50%;" />

总结：

1.说起IO，底层一定想起系统调用recvfrom，对数据进行准备和复制。

2.任何数据的读取，需要有这两步，内核态数据准备，内核复制到用户态。

2.五种模式的区别无非就是，请求方是否等待和轮询(是否完成准备和复制)，响应方是否主动通知。

(

1.阻塞：从建立连接，发起系统调用，数据复制 一直阻塞。(发生了recvfrom系统调用)

2.非阻塞：发起系统调用，直接得到一个未完成的结果，然后不然轮询是否复制完成，完成后(发生了recvfrom系统调用)

3.IO复用：单线程监听所有连接的建立和读写请求，去处理他们的请求。(发生了select系统调用和recvfrom)

4.信号驱动IO：建立信号处理程序，等待数据准备完成的信号，再来recvfrom，进行数据复制。(发生信号通知调用和recvfrom)

5.异步IO：直接告知需要的数据，直接等待完成数据复制。

)
