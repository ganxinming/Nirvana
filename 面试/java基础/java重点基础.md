### **八种基本数据类型的大小，以及他们的封装类**

**基本类型 大小（字节） 默认值 封装类**

byte 1 (byte)0 Byte

short 2 (short)0 Short

int 4 0 Integer

long 8 0L Long

flfloat 4 0.0f Float

double 8 0.0d Double

boolean - false Boolean

char 2 \u0000(null) Character



基本数据类型在声明时系统会自动给它分配空间，而引用类型声明时只是分配了引用空间，

必须通过实例化开辟数据空间之后才可以赋值。数组对象也是一个引用对象，将一个数组赋值给另

一个数组时只是复制了一个引用，所以通过某一个数组所做的修改在另一个数组中也看的见。

## Java自动装箱与拆箱

装箱就是自动将基本数据类型转换为包装器类型Integer**valueOf(int)** **方法**

拆箱就是自动将包装器类型转换为基本数据类型调用方法：Integer的intValue方法



在通过valueOf方法创建Integer对象的时候，如果数值在[-128,127]之间，

便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。

(但是浮点数，是没有缓存的，也就是说double和float没有这个范围内的缓存)

## 重写

 1.发生在父类与子类之间 2.方法名，参数列表相同，返回类型（除过子类中方法的返回类型

是父类中返回类型的子类） 3.访问修饰符的限制一定要大于被重写方法的访问修饰符

（public>protected>default>private) 4.重写方法一定不能抛出新的检查异常或者比被重写方法申

明更加宽泛的检查型异常



## 重载

在一个类中，同名的方法如果有不同的参数列表（**参数类型不同、参数个数不同甚至是参数顺序不**

**同**）则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但**不能通过返回类型是**

**否相同来判断重载**。



### **String，String StringBuffffer**和StringBuilder** 的区别是什么

String是只读字符串，它并不是基本数据类型，而是一个对象。从底层源码来看是一个fifinal类型的

字符数组，所引用的字符串不能被改变，一经定义，无法再增删改。每次对String的操作都会生成

新的String对象。

每次+操作 ： 隐式在堆上new了一个跟原字符串相同的StringBuilder对象，再调用append方法 拼 

接+后面的字符。



 StringBuffffer 对方法加了同步锁或者对调用的方法加了同步锁，所

以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。

##  Collection包结构，与Collections的区别

Collection是集合类的上级接口，子接口有 Set、List、LinkedList、ArrayList、Vector、Stack、

Set；Collections是集合类的一个帮助类， 它包含有各种有关集合操作的静态多态方法，用于实现对各种

集合的搜索、排序、线程安全化等操作。此类不能实例化，就像一个工具类，服务于Java的

Collection框架。



# Java创建对象有几种方式？

new创建新对象

通过反射机制

采用clone机制

通过序列化机制

## 有没有可能两个不相等的对象有相同的hashcode

有可能.在产生hash冲突时,两个不相等的对象就会有相同的 hashcode 值.当hash冲突产生时,一般

有以下几种方式来处理:

- 拉链法:每个哈希表节点都有一个next指针,多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表进行存储.
- 开放定址法:一旦发生了冲突,就去寻找下一个空的散列地址,只要散列表足够大,空的散列地址总能找到,并将记录存入
- 再哈希:又叫双哈希法,有多个不同的Hash函数.当发生冲突时,使用第二个,第三个….等哈希函数计算地址,直到无冲突.

# final有哪些用法?

- 被fifinal修饰的类不可以被继承
- 被fifinal修饰的方法不可以被重写
- 被fifinal修饰的变量不可以被改变.如果修饰引用,那么表示引用不可变,引用指向的内容可变. 
- 被fifinal修饰的方法,JVM会尝试将其内联,以提高运行效率(如果指定了一个类为final，则该类所有的方法都是final的。Java编译器会寻找机会内联所有的final方法，内联对于提升Java运行效率作用重大)
- 被fifinal修饰的常量,在编译阶段会存入常量池中.（编译期间就可以把这些内容放入常量池中）

## 3*0.1 == 0.3返回值是什么

false,因为有些浮点数不能完全精确的表示出来.

## a=a+b与a+=b有什么区别吗?

+= 操作符会进行隐式自动类型转换,此处a+=b隐式的将加操作的结果类型强制转换为持有结果的类

型,而a=a+b则不会自动进行类型转换.如：

short s1= 1;

s1 = s1 + 1;

有错误.short类型在进行运算时会自动提升为int类型,也就是说 s1+1 的运算结果是int类型,而s1是

short类型,此时编译器会报错.



## try catch finally，try里有return，finally还执行么？

执行，并且fifinally的执行早于try里面的return结论：

1、不管有木有出现异常，fifinally块中代码都会执行；

2、当try和catch中有return时，fifinally仍然会执行；

3、fifinally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的

值保存起来，管fifinally中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数

返回值是在fifinally执行前确定的；

4、fifinally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。